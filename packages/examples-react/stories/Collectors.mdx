import {Meta} from '@storybook/addon-docs/blocks'

<Meta title="Guides/Collectors" />

# Collectors Reference

The addon uses modular collector classes for metrics gathering. Each collector uses the most accurate available browser API for its metrics.

## Overview

<table>
  <thead>
    <tr>
      <th>Collector</th>
      <th>Method</th>
      <th>Type</th>
      <th>Browser Support</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>FrameTimingCollector</strong></td>
      <td><code>requestAnimationFrame</code> loop</td>
      <td>Heuristic</td>
      <td>All</td>
    </tr>
    <tr>
      <td><strong>InputCollector</strong></td>
      <td>Event Timing API</td>
      <td><strong>Optimal</strong></td>
      <td>Chrome 96+, Firefox 144+</td>
    </tr>
    <tr>
      <td><strong>MainThreadCollector</strong></td>
      <td>Long Tasks API</td>
      <td><strong>Optimal</strong></td>
      <td>Chrome 58+</td>
    </tr>
    <tr>
      <td><strong>LongAnimationFrameCollector</strong></td>
      <td>LoAF API</td>
      <td><strong>Optimal</strong></td>
      <td>Chrome 123+</td>
    </tr>
    <tr>
      <td><strong>ElementTimingCollector</strong></td>
      <td>Element Timing API</td>
      <td><strong>Optimal</strong></td>
      <td>Chrome 77+</td>
    </tr>
    <tr>
      <td><strong>LayoutShiftCollector</strong></td>
      <td>Layout Instability API</td>
      <td><strong>Optimal</strong></td>
      <td>Chrome 77+</td>
    </tr>
    <tr>
      <td><strong>MemoryCollector</strong></td>
      <td><code>performance.memory</code></td>
      <td><strong>Optimal</strong></td>
      <td>Chrome only</td>
    </tr>
    <tr>
      <td><strong>PaintCollector</strong></td>
      <td>Paint Timing API</td>
      <td><strong>Optimal</strong></td>
      <td>All</td>
    </tr>
    <tr>
      <td><strong>StyleMutationCollector</strong></td>
      <td><code>MutationObserver</code></td>
      <td>Heuristic</td>
      <td>All</td>
    </tr>
    <tr>
      <td><strong>ForcedReflowCollector</strong></td>
      <td>Property getter instrumentation</td>
      <td>Heuristic</td>
      <td>All</td>
    </tr>
    <tr>
      <td><strong>ReactProfilerCollector</strong></td>
      <td>React Profiler API</td>
      <td><strong>Optimal</strong></td>
      <td>All</td>
    </tr>
  </tbody>
</table>


**Optimal** = Uses the browser's native/standard API designed for this measurement.
**Heuristic** = Uses indirect measurement techniques; accuracy may vary.

---

## Frame Timing

Measures rendering smoothness using a `requestAnimationFrame` loop.

**Metrics:** FPS, frame time, dropped frames, frame jitter, frame stability (%)

The RAF loop calculates delta time between frames. Dropped frames are those exceeding 2× the 16.67ms budget (33.34ms). Frame stability is a consistency percentage based on deviation from the target frame time.

---

## Input Responsiveness

Uses the [Event Timing API](https://w3c.github.io/event-timing/) for accurate interaction measurement — the same API behind the INP Core Web Vital.

**Metrics:** INP (p98), input latency, processing time, presentation delay, FID, interaction details

Each interaction is broken down into three phases:
- **Input delay** — time before event handlers start (main thread busy?)
- **Processing time** — event handler execution duration
- **Presentation delay** — time from handlers to next paint

Click "Inspect" on any interaction to highlight and scroll to the target element.

---

## Main Thread Health

Uses the [Long Tasks API](https://w3c.github.io/longtasks/) to detect tasks blocking the main thread for &gt;50ms.

**Metrics:** Long task count, longest task duration, Total Blocking Time (TBT)

TBT is calculated as the sum of `(duration - 50ms)` for all long tasks, matching the Lighthouse methodology.

---

## Long Animation Frames

Uses the [Long Animation Frames API](https://w3c.github.io/long-animation-frames/) (Chrome 123+) for detailed frame attribution.

**Metrics:** LoAF count, blocking duration, P95 duration, script attribution

Unlike Long Tasks, LoAF provides **script attribution** — which functions in which files caused the slow frame. This is essential for debugging INP issues.

---

## Layout Stability

Uses the [Layout Instability API](https://w3c.github.io/layout-instability/) with session windowing per the Core Web Vitals specification.

**Metrics:** CLS score, layout shift count, session tracking

CLS uses session windows: groups of shifts with &lt;1s gaps and &lt;5s total duration. The final CLS is the maximum session window value.

---

## React Profiler

Uses the official [React Profiler API](https://react.dev/reference/react/Profiler) via a wrapper component.

**Metrics:** Mount count/duration, slow updates (&gt;16ms), P95 duration, render cascades

Render cascades (`nested-update` phase) indicate `setState` called during commit phase — typically in `useLayoutEffect`. These are synchronous re-renders and are expensive.

---

## Memory & Resources

Uses `performance.memory` (Chrome only) for heap introspection, plus Paint Timing and Resource Timing APIs.

**Metrics:** Heap usage, memory delta, GC pressure (MB/s), compositor layers, paint count, script eval time

GC pressure is calculated as the allocation rate over a rolling window — sustained high values (&gt;1 MB/s) indicate memory-intensive operations.
